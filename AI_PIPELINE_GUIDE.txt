AI PIPELINE — ENTRY & EXIT POINT GUIDE
=======================================

This document explains how the AI pipeline works, file by file,
from where data enters to where results come out.


========================================
THE SHORT VERSION
========================================

  User fills form
       |
       v
  user_app/services/ai_service.py    <-- ENTRY POINT (code enters here)
       |
       v
  core/ai/gateway.py                 <-- CHOKEPOINT (all checks happen here)
       |
       v
  core/ai/planner.py                 <-- calls Claude API (plan)
  core/ai/html_generator.py          <-- calls Claude API (HTML)
  core/ai/css_generator.py           <-- calls Claude API (CSS)
       |
       v
  SitePlan / SiteVersion             <-- EXIT POINT (results come out here)


========================================
DETAILED FLOW — STEP BY STEP
========================================


STEP 1: USER SUBMITS BUSINESS INFO
-----------------------------------
File: user_app/services/ai_service.py (lines 29-35)

This is the ENTRY POINT. When a user fills out their business info
and clicks "generate", the route handler calls one of these:

  run_planner_for_project(project, user)  -> returns SitePlan
  run_generator_for_project(project, user) -> returns SiteVersion

These functions do NOT contain logic. They just:
  1. Call the gateway
  2. Save the result (stub for now)

Why it exists:
  - Separates HTTP concerns from business logic
  - Later this is where database save/load happens
  - Routes never talk to core/ai/ directly


STEP 2: GATEWAY ENFORCES ALL RULES
-----------------------------------
File: core/ai/gateway.py

This is the CHOKEPOINT. Every AI call must pass through here.
There are exactly 2 public functions:

  generate_plan(project, user)   -> SitePlan
  generate_site(project, user)   -> SiteVersion

What generate_plan() does, in order:
  1. check_ai_limit()    — has user used their quota? (FREE=1, PAID=5)
  2. check_cooldown()    — was last call too recent? (30 sec gap required)
  3. check_rate_limit()  — too many calls in sliding window? (10 per 60 sec)
  4. run_planner()       — call Claude API
  5. project.site_plan = plan   — save result on project object
  6. increment_usage()   — bump planner_calls counter
  7. record_call()       — log timestamp for rate limiting
  8. transition()        — move state MEMORY_READY -> PLAN_READY

If step 4 fails, the project goes to ERROR state.
If steps 1-3 fail, they raise and the project state stays unchanged.

What generate_site() does (same pattern):
  1. check_ai_limit()    — generation quota
  2. check_cooldown()
  3. check_rate_limit()
  4. run_html_generator() — call Claude for HTML
  5. run_css_generator()  — call Claude for CSS
  6. project.site_version = SiteVersion(html, css)
  7. increment_usage()    — bump generation_calls (ONE increment for TWO API calls)
  8. record_call()
  9. transition()         — move PLAN_APPROVED -> SITE_GENERATED


STEP 3: CHECKS THAT HAPPEN BEFORE AI
--------------------------------------

  File: core/limits/ai_limits.py
  --------------------------------
  check_ai_limit(usage, plan, action)
    - Looks at AIUsage.planner_calls or .generation_calls
    - Compares against AI_LIMITS from config/settings.py
    - FREE: 1 planner call, 1 generation call
    - PAID: 5 planner calls, 5 generation calls
    - Raises AILimitExceeded if over quota

  File: core/limits/cooldowns.py
  --------------------------------
  check_cooldown(usage)
    - Looks at AIUsage.last_ai_call_at
    - If less than 30 seconds ago, raises AICooldownActive
    - Prevents rapid-fire abuse

  File: core/limits/rate_limits.py
  --------------------------------
  check_rate_limit(user_id)
    - In-memory sliding window (dict of timestamps)
    - If 10+ calls in last 60 seconds, raises AIRateLimited
    - Global safety net


STEP 4: AI AGENTS CALL CLAUDE
-------------------------------

Each agent follows the same pattern:
  1. Load prompt template from .txt file
  2. Fill in variables from BrandMemory / SitePlan
  3. Call Claude API via anthropic SDK
  4. Strip markdown fences from response (defensive)
  5. Parse the result
  6. Validate the result
  7. Return typed object

  File: core/ai/planner.py
  --------------------------
  run_planner(brand_memory) -> SitePlan

  Input:  BrandMemory (business name, type, goal, etc.)
  Prompt: core/ai/prompts/planner.txt
  Output: JSON parsed into SitePlan with SectionPlan list
  Validates: sections not empty, unique IDs, has page_title

  File: core/ai/html_generator.py
  ---------------------------------
  run_html_generator(site_plan, brand_memory) -> HTMLOutput

  Input:  SitePlan + BrandMemory
  Prompt: core/ai/prompts/html.txt
  Output: Full HTML document string
  Validates:
    - No <script> tags
    - No onclick/onerror/onload handlers
    - Has <nav> element
    - Has <footer> element
    - Has <!DOCTYPE html>

  File: core/ai/css_generator.py
  --------------------------------
  run_css_generator(html, brand_memory) -> CSSOutput

  Input:  HTML string + BrandMemory (for colors/theme)
  Prompt: core/ai/prompts/css.txt
  Output: CSS string
  Validates:
    - No @import rules
    - No external URLs (data: URIs are OK)


STEP 5: RESULTS COME OUT
--------------------------
After the gateway finishes:

  generate_plan() returns:
    SitePlan
      .page_title        "Sunrise Bakery - Fresh baked daily"
      .meta_description   "A family-owned Portland bakery..."
      .sections           [SectionPlan, SectionPlan, ...]

  generate_site() returns:
    SiteVersion
      .html              "<!DOCTYPE html>..."
      .css               "body { margin: 0; ... }"
      .version           1
      .is_published      False

These are the EXIT POINTS. The service layer receives them
and will eventually save to database.


========================================
STATE MACHINE — THE BACKBONE
========================================

Every project has a state. The state controls what actions are allowed.

  DRAFT              Project just created
    |
  INPUT_READY        User can fill in business info
    |
  MEMORY_READY       Business info saved (BrandMemory exists)
    |
  PLAN_READY         AI planner has run, SitePlan exists
    |
  PLAN_APPROVED      User reviewed and approved the plan
    |
  SITE_GENERATED     AI generated HTML + CSS
    |
  PREVIEW            User can preview the site
    |
  PUBLISHED          Site is live

  ERROR              Something broke (can go back to DRAFT)

Files involved:
  core/state_machine/states.py       — the enum
  core/state_machine/transitions.py  — which transitions are legal
  core/state_machine/engine.py       — transition() function
  core/state_machine/guards.py       — preconditions for transitions

The gateway calls transition() AFTER the AI succeeds.
If AI fails, it calls transition_to_error() instead.

Guards prevent nonsense:
  - Can't go to PLAN_READY without brand_memory
  - Can't go to SITE_GENERATED without site_plan
  - Can't go to PREVIEW without site_version


========================================
ERROR FLOW
========================================

  Problem                     Exception raised        Caught where
  -------                     ----------------        ------------
  User hit quota              AILimitExceeded         service -> HTTP 429
  Called too fast (cooldown)   AICooldownActive        service -> HTTP 429
  Rate limit exceeded          AIRateLimited           service -> HTTP 429
  Invalid state transition     InvalidStateTransition  service -> HTTP 400
  Guard failed                 GuardFailure            service -> HTTP 400
  Claude API failed            AIGenerationError       service -> HTTP 500
  AI output invalid            AIValidationError       gateway catches -> ERROR state

All exceptions inherit from CoreError.
The gateway catches AI failures and moves the project to ERROR state.
Limit/rate/cooldown errors do NOT change project state.


========================================
FILE MAP — WHAT EACH FILE DOES
========================================

config/
  settings.py              Env vars + limits config

core/
  errors.py                All exception classes

core/models/
  user.py                  User dataclass + PlanType enum (FREE/PAID)
  brand_memory.py          BrandMemory dataclass (business info)
  ai_usage.py              AIUsage dataclass (call counters)
  site_version.py          SiteVersion dataclass (html + css)
  project.py               Project dataclass (ties everything together)

core/state_machine/
  states.py                ProjectState enum (9 states)
  transitions.py           Legal transitions map
  engine.py                transition() + transition_to_error()
  guards.py                Precondition checks before transitions

core/limits/
  ai_limits.py             Per-plan quota enforcement
  rate_limits.py           Sliding window rate limiter
  cooldowns.py             Per-user cooldown timer

core/ai/
  schemas.py               SitePlan, HTMLOutput, CSSOutput dataclasses
  prompts/planner.txt      Planner system prompt template
  prompts/html.txt         HTML generator prompt template
  prompts/css.txt          CSS generator prompt template
  planner.py               Calls Claude -> returns SitePlan
  html_generator.py        Calls Claude -> returns HTMLOutput
  css_generator.py         Calls Claude -> returns CSSOutput
  gateway.py               SINGLE ENTRY to AI (checks + calls + transitions)

user_app/services/
  ai_service.py            Service bridge (routes call this, this calls gateway)


========================================
TESTING
========================================

Offline (no API key needed):
  uv run python test_ai_pipeline.py

Live (costs ~$0.03, needs API credits):
  uv run python test_ai_pipeline.py --live

After live test, open test_output.html in your browser to see the site.


========================================
WHAT'S NOT BUILT YET
========================================

- Database layer (objects are in-memory only)
- HTTP routes (user_app/routes/generation.py is empty)
- Onboarding UI (user_app/frontend/pages/onboarding.py is empty)
- Publishing pipeline (core/publishing/ is empty)
- Auth (user_app/auth/ is empty)
- Billing/trial (core/billing/ is empty)
